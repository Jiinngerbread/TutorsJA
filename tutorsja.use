/* Group: TripleJ */

model TutorsJA

-- ENUMS -- 
enum GeneralStatus {Not_Approved, Approved, Verified}
enum Grade {Kg3, One, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Eleven}
enum AvailabilityStatus {Free, Fully_Booked, Not_Accepting_Requests, Service_Withdrawn}
enum ModeOfDelivery {Online, Face_To_Face, Blended}
enum ServiceType {One_On_One, Group}
enum Days {Mon, Tue, Wed, Thru, Fri, Sat, Sun}
enum Ratings {STAR1, STAR2, STAR3, STAR4, STAR5}
enum SRStatus {Unanswered, Answered, Resolved, Outdated}
enum Sex {Male, Female}
enum EnrollmentStatus {Accepted, Denied, Pending}



-- DATATYPE CLASSES --
class Date 
attributes 
    day: Integer
    month: Integer
    year: Integer
operations
    DateInit(d: Integer, m: Integer, y: Integer)
    begin
        self.day := d;
        self.month := m;
        self.year:= y;
    end
end

class Period  --to be used to show a range of days on a calendar or period within which a service is offered
attributes
    startDate: Date
    endDate: Date
operations
    PeriodInit(sDate: Date, eDate: Date)
    begin
        self.startDate := sDate;
        self.endDate := eDate;
    end
end


-- ABSTRACT CLASSES --

abstract class User -- the D2 said its abstract --
attributes 
    fname: String
    lname: String
    sex: Sex
    location: String
operations
    UserInit(f:String, l:String, s:Sex, loc:String)
    begin   
        self.fname := f;
        self.lname := l;
        self.sex := s;
        self.location := loc;
    end 
end 


abstract class Calendar --Thought needs to be given to this representation 
attributes
    dayNotes: Set(Tuple(date:Date, note:String));
operations
    CalendarInit(dns:Set(Tuple(date:Date, note:String)))
    begin   
        self.dayNotes := dns;
    end 
end


abstract class Service
attributes
    grade: Grade
    subject: String --so they can only do one subject even in group classes; that's what we want to say, right?
    location: String
    modeOfDelivery: ModeOfDelivery
    serviceType: ServiceType
    duration: Period
    initialDur: Period 
    meetingDays: Set (Days)
    numOfSlots: Integer
    currentRun: Period
    rate: Ratings
    --rate: Real
    availStatus: AvailabilityStatus
operations  
    ServiceInit(g:Grade, s:String, loc:String, mod:ModeOfDelivery, st:ServiceType, d:Period, mds:Set (Days), nos:Integer, rate: Ratings)
    begin   
        self.grade := g;
        self.subject := s;
        self.location := loc;
        self.modeOfDelivery := mod;
        self.serviceType := st;
        self.initialDur :=  d;
        self.meetingDays := mds;
        self.numOfSlots := nos;
        self.rate := Ratings::STAR3;
        self.availStatus := AvailabilityStatus::Free;
    end

end


-- ? abstract class Policy end  --?

-- ? abstract class Rule end --?

-- CONCRETE CLASSES --
class Child
attributes
    fname: String
    lname: String
    dob: Date
    sex: Sex
    grade: Grade
    subjects: Set (String) --possible collection of subjects of interest --still need to check if set works like this but should since Miss used it as operation return types 
    modesOfDelivery: Set (ModeOfDelivery) --maybe a Set for this as well in case they want a different mode for each type of service for eg
    serviceTypes: Set (ServiceType) --set since they may enroll in many services; may want both private and group
    specialNeeds: Set (String) --review this; good with me - suggesting a Set though
    location: String --may not need this; I think we should keep it
operations
    ChildInit(f:String, l:String, d:Date, s:Sex, g:Grade, sub:Set (String), mod:Set (ModeOfDelivery), sts:Set (ServiceType), sns: Set(String), loc:String)
    begin   
        self.fname := f;
        self.lname := l;
        self.dob := d;
        self.sex := s; 
        self.grade := g;
        self.subjects := sub;
        self.modesOfDelivery := mod;
        self.serviceTypes := sts;
        self.specialNeeds := sns;
        self.location := loc;
    end
constraints
    --A child must have a minimum age of 5 and a child must be below the age of 19. 
    inv ageFiveToNineteen:
        self.age >= 5 and < 19

end

class SpecialRequest 
attributes
    msgBody: String 
    --tags: String
    grade: Grade
    subjects: Set (String)
    modesOfDelivery: Set (ModeOfDelivery)
    specialNeeds: Set (String)
    location: String 
    status: SRStatus
    neededBy: Period
    daysPast: Date
operations  
    SpecialRequestInit(msg:String, t:String, g:Grade, s:Set (String), mod:Set (ModeOfDelivery), sns:Set (String), loc: String, needBy:Period, currentDate: Date)
    begin   
        self.msgBody := msg;
        self.grade :=  Grade::Kg3;
        self.subjects := s;
        self.modesOfDelivery := mod;
        self.specialNeeds := sns;
        self.location := loc;
        self.status := SRStatus::Unanswered;
        self.neededBy := needBy
        self.daysPast := currentDate
    end

    SpecialRequestInit(msg:String, t:String, g:Grade, s:Set (String), mod:Set (ModeOfDelivery), sns:Set (String), loc: String, currentDate: Date) --overloaded constructor 
    begin   
        self.msgBody := msg;
        self.grade :=  Grade::Kg3;
        self.subjects := s;
        self.modesOfDelivery := mod;
        self.specialNeeds := sns;
        self.location := loc;
        self.status := SRStatus::Unanswered;
        self.neededBy := NULL
        self.daysPast := currentDate
    end

constraints
    --A Special Request existing without a date-needed-by date will become outdated after 31 days
    inv autoOutdate:
        (self.neededBy = NULL and self.daysPast < self.period.lengthofPeriod()) implies self.status = SRStatus::"Outdated"
end 

class Payment
attributes
    amount: Real
    datePayed: Date
operations
    PaymentInit(a: Real, dp: Date)
    begin   
        self.amount := a;
        self.datePayed := dp;
    end 
end


-- EXTENDED CONCRETE CLASSES --

class Parent < User
attributes
    children: Set (Child) 
    hasPending: Boolean
operations
    ParentInit(f:String, l:String, s:Sex, loc:String, c:Set (Child))
    begin   
        self.UserInit(f, l, s, loc);
        self.children := c;
    end
constraints
    --Parents may only send enrollment requests to Tutors for a service whose availability is “free”. 

    --A parent may rate a tutor after ½ of the service their child is enrolled in is completed.

    --A Parent may review a tutor only after rating a Tutor. 


    

end

class Tutor < User
attributes 
    grades: Set (Grade)
    subjects: Set (String)
    generalStatus: GeneralStatus
    --availStatus: AvailabilityStatus --not sure if this is how it is to be done-- I think we'd keep this for each service
    certifications: Set (String)
    special_needs: Set (String)
operations
    TutorInit(f:String, l:String, s:Sex, loc:String, gs:Set (Grade), subs:Set(String), sns:Set(String))
    begin   
        self.UserInit(f, l, s, loc);
        self.grades := gs;
        self.subjects := subs;
        self.generalStatus := GeneralStatus::Not_Approved;
        --self.certifications := NULL;
        self.special_needs := sns;
    end
    
    UpdateGeneralStatus(newGStatus: GeneralStatus)
    begin   
        self.generalStatus := newGStatus;
    end

    AddCertification(cert:String)
    begin
        --add cert to certifications Set
    end


end 

class PrivateService < Service 
attributes 
    description: String
    --! serviceCap: Integer --represents the max number of one-on-one a tutor may have at any given point -- thinking this should be in the Service class; removed it from Init for now
operations
    PrivateServiceInit(g:Grade, s:String, loc:String, mod:ModeOfDelivery, st: ServiceType, d:Period, mds:Set (Days), nos:Integer, rate:Ratings, descr: String) --can I initialize ..like this-- not sure, but probably; in adjusting the line, wrote the initialization like this just in case for now
    begin
        st:= ServiceType::One_On_One;
        rate:= Ratings::STAR3;
        self.ServiceInit(g, s, loc, mod, st, d, mds, nos, rate);
        self.description := descr;
        --self.serviceCap := cap;
    end


end 

class GroupService < Service 
attributes 
    description: String 
operations
    GroupServiceInit(g:Grade, s:String, loc:String, mod:ModeOfDelivery, st:ServiceType, d:Period, mds:Set (Days), nos:Integer, rate:Ratings, descr: String)
    begin   
        st := ServiceType::Group;
        rate:= Ratings::STAR3;
        self.ServiceInit(g, s, loc, mod, st, d, mds, nos, rate);
        self.description := descr; 
    end    
end 


-- ASSOCIATIONS IN MODEL -- 

association ServiceOffering between
    Tutor[1] role tutor
    Service[*] role service
end

-- association TutorRating between 
--     Rating[1] role rating
--     Tutor[1] role Tutor 
--     Child[1] role student
-- end 

-- association TutorReview between 
--     Rating[1] role rating
--     Tutor[1] role Tutor 
--     Child[1] role student
-- end

association TutorCalendar between 
    Calendar[1] role schedule
    Tutor[1] role tutor
end

association ChildCalendar between 
    Calendar[1] role schedule 
    Child[1] role student
end

association ChildOf between 
    Parent[1] role parent
    Child[1..*] role child
end

association OneOnOneEnrollment between 
    Child[1] role student 
    Tutor[1] role instructor 
end 

association GroupEnrollment between 
    Child[*] role students 
    Tutor[1] role groupInstructor 
end 

-- association relatedReview between 
--     Rating[1] role ratings 
--     Review[0..1] role review
-- end 

-- association Conversation between
--     Dialogue[*] role messages 
--     Tutor[1] role reciever 
--     Parent[1] role reciever
-- end 

-- association SpecialRequestInteraction between 
--     Parent[1] role requestor 
--     SpecialRequest[1] role messages
--     Proposal[*] role responses
-- end 

association ServicePayment between 
    Payment[1..*] role payments 
    Parent[1] role payer
    Tutor[1] role payee
    --ServiceOffering[1..*] role service 
    --Enrollment[1] role establishedStudent
    Child[1] role forChild
end

--association Enrollment between 
--    Parent[1] role liaison 
--    Child[1] role potentialStudent
--    Service[1] role interestedService
--    Tutor[1] role potentialInstructor 
--end 

association CreateSpecialMsg between 
    Parent[1] role spCreator 
    SpecialRequest[1..*] role request
end


-- ASSOCIATION CLASS -- 
associationclass Proposal between
    SpecialRequest[1] role request
    Tutor[1] role tutor
attributes
    proposal: String
end

associationclass Review between
    Parent[1]  
    Service[1]  
attributes 
    rating: Ratings
    reviewTxt: String
end 

associationclass Dialogue between
    Parent[1] role chatInitiator
    Tutor[1] role charRcvr
attributes 
    parent: Parent
    tutor: Tutor
    pMsg: String 
    tMsg: String 
end 


associationclass EnrollmentRequest between 
    Parent[1] role liaison 
    Child[1] role potentialStudent
    Service[1] role interestedServive
    Tutor[1] role potentialInstructor 
attributes
    status: EnrollmentStatus
    TutorAgreement: Boolean init: false
    ParentAgreement: Boolean init: true
operations
    EnrollmentRequestInit()
    begin
        self.status := EnrollmentStatus:: Pending;
    end

   /* updateAgreement(reponse: Boolean, rolename: String)
    begin
        if rolename := PARENT then 
            self.ParentAgreement := response;
        else
            rolename := TUTOR then 
            self.TutorAgreement := response;
        endif
    end */

/* constraints
    inv AcceptedEnrollment: 
        if self.TutorAgreement = true or self.ParentAgreement = true then
            self.status = EnrollmentStatus::Accepted
        else
            if self.TutorAgreement = false or self.ParentAgreement = false then
                self.status = EnrollmentStatus::Denied 
        endif
    end */

end


-- constraints must be expressed in theire relevant classes-- 

--Parents may have only one pending enrollment request at a time for a particular Tutor’s service for their child

context Parent::SendEnrollmentReq():
pre: self.hasPending = false


--parents may only send enrollment requests to Tutors  for a service whose availability is “free” 

context Parent::SendEnrollmentReq():

--A parent may rate a tutor after ½ of the service their child is enrolled in is completed.  
context Calendar::RateTutor():
pre: rating <> NULL implies duration > initialDur

--Only tutors who are approved may offer services 
context Tutor:
pre: (self->collect(services)-size() > 0) implies self.generalStatus = GeneralStatus::Approved

















