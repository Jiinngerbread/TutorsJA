/* Group: TripleJ */

model TutorsJA


-- ENUMS -- 
enum Sex {Male, Female}
enum Grade {Kg3, One, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Eleven}
enum SubjectName {Math, EngLang, EngLit, Spanish, History, Science, SocStudies, IT, ReadingComp, Phonics, Penmanship, Art, Music, POB, Accounts, Physics, Chemistry, Biology, Geography}
enum GeneralStatus {Not_Approved, Approved, Verified}
enum AccountStatus {Good, Delinquent}
enum Days {Mon, Tue, Wed, Thru, Fri, Sat, Sun}
enum ModeOfDelivery {Online, Face_To_Face, Blended}
enum ServiceType {One_On_One, Group}
enum AvailabilityStatus {Free, Fully_Booked, Not_Accepting_Requests, Service_Withdrawn}
enum ActiveStatus {Not_Started, Active, Ended, Closed}
enum EnrollmentStatus {Accepted, Denied, Pending}
enum AgrStatus{Agree, Disagree}
enum Ratings {STAR1, STAR2, STAR3, STAR4, STAR5}
enum SRStatus {Unanswered, Answered, Resolved, Outdated}
enum MatchLeveL {None, Weak, Moderate, Strong}
enum SubscriptionPeriod{Monthly, ThreeMonths, Annual}



-- DATATYPE CLASSES --
class Time 
attributes 
	hour: Integer --uses 24-hour format
	min: Integer
operations
    TimeInit(h: Integer, min: Integer)
    begin
        self.hour := h;
		self.min := min;
    end

	equalsT(t: Time): Boolean
	begin
		if self.hour = t.hour and self.min = t.min then
			begin
				result := true
			end;
		end;
	end

	beforeT(t: Time): Boolean
	begin
		result := false 
		if self.hour < t.hour then
			begin
				result := true
			end;
		else
			begin
				if self.min < t.min then
					begin
						result := true
					end;
			end;
		end;
	end
end

class Date 
attributes 
	day: Integer
    month: Integer
    year: Integer
operations

    DateInit(d: Integer, m: Integer, y: Integer)
    begin
        self.day := d;
        self.month := m;
        self.year:= y;
    end

	equalsD(d: Date): Boolean
	begin
		if self.day = d.day and self.month = d.month and self.year = d.year then
			begin
				result := self.day = d.day and self.month = d.month and self.year = d.year
			end;
		end;
	end

	beforeD(d: Date): Boolean
	--given d1.beforeD(d2), gives true if d1 comes before d2
	begin
	-- 	if self.year <= d.year and self.month <= d.month and self.day < d.day then
	-- 		begin
	-- 			self.year <= d.year and self.month <= d.month and self.day < d.day
	-- 		end;
	-- 	end;
	-- end

		result := false 
		if self.year < d.year then
			begin
				result := true
			end;
		else
			begin
				if self.month < d.month then
					begin
						result := true
					end;
				else 
					begin
						if self.day < d.day then
							begin
								result := true
							end;
					end;
			end;
		end;
	end
		


end

class Period  
attributes
    startDate: Date
    endDate: Date
operations
    PeriodInit(sDate: Date, eDate: Date)
    begin
        self.startDate := sDate;
        self.endDate := eDate;
    end

	equals(p:Period): Boolean
	begin
		result := self.startDate.equalsD(p.startDate) and p.endDate.equalsD(P.endDate)
	end

	-- isGreaterThan(p:Period): Boolean
	-- begin
	-- end

	before(p:Period): Boolean
	--given p1.before(p2), gives true if p1 comes before p2
	begin
		result := self.endDate.beforeD(p.endDate)
	end

	overlap(p:Period): Boolean
	--given p1.overlap(p2), gives true if p1 does NOT end before p2 starts 
										--OR p2 does NOT end before p1 starts

	--IGNORE given p1.overlap(p2), gives true if p1 starts at the same time as p2 
										--IGNORE OR if p1 starts before p2 ends and 
										--IGNORE OR if p1 starts when p2 ends
										--IGNORE OR if p1 ends before p2 ends and starts when or after p2 starts
	begin
		-- result := self.startDate.equalsD(p.startDate) 
		-- 			or self.startDate.beforeD(p.endDate)
		-- 			or self.startDate.equalsD(p.endDate) 
		-- 			or self.endDate.beforeD(p.endDate)

		result := self.endDate.beforeD(p.startDate) <> true 
					or p.endDate.beforeD(self.startDate) <> true
	end

	contains(p:Period): Boolean
	--given p1.contains(p2), gives true if p2 occurs within p1 
		-- i.e. : gives true if p1 is NOT equal to p2 
								--AND p2 starts as or after p1 starts 
								--AND p2 ends as or before p1 ends
	begin
		result := self.equals(p) <> true and	
					( p.startDate.equalsD(self.startDate) 
					  or 
					  self.startDate.beforeD(p.startDate)
					)
					and
					( p.endDate.equalsD(self.endDate) 
					  or
					  p.endDate.beforeD(self.endDate)
					)
	end
end

class Subject
attributes
	name: SubjectName
	gradeLevel: Grade
end

class Session
attributes
	day: Days
	startTime: Time 
	endTime: Time 
	recurring: Boolean
	startRecurring: Date
	endRecurring: Date
	-- duration: Period
    -- initialDur: Period --?
end

class ModeOfDel
attributes
	mod: ModeOfDelivery
end

class TypeOfService
attributes		
	type: ServiceType
end


-- ABSTRACT CLASSES --

-- abstract class Receiver
-- attributes
-- end 

abstract class Role 
attributes	
end

-- CONCRETE CLASSES --

class Person
attributes
	fname: String
	lname: String
	username: String
	password: String
	sex: Sex
	isParent: Boolean
	location: String
--operations
constraints
	--A person cannot have more than one tutor role
	inv: 
		self -> select(ocl.isKindof(Tutor)) -> size() <= 1 
		
	--person:isParent = True implies cannot enrol with tutors who belong to the same person
	--inv noSelfEroll:
	--	self.isParent = true implies forAll(t:Tutor| self <> t)
		
	--A person who is a parent must have atleast one child
	inv:
		self.isParent = true implies self -> select(ocl.isKindof(Child)) -> size() >= 1
end 

class Service
attributes
	-- gradeLvl: Grade
    location: String
    numOfSpaces: Integer init: 1
    currentDate: Date 
	startDate: Date
	endDate: Date
    rate: Real
    availStatus: AvailabilityStatus 
	activeStatus: ActiveStatus init:ActiveStatus::Not_Started
-- operations
--  UpdateNumOfSpaces(num:Integer)
	--pre: type of service is group
	--pre: self.tutor.accStatus <> delinquent and self.tutor.generalStatus <> Not_Approved
	--post:  if type of service is group, nuOfSpaces = nuOfSpaces@pre + num

-- 	UpdateActiveStatus()
-- 	begin
-- 		
-- 		if self.sessionsInServ->slot->attendance->select(participant.isTypeOf(Tutor))->exists(a | a.present = true) then
-- 			begin 
-- 				self.activeStatus := ActiveStatus::Active
-- 			end;
-- 		else
			--begin
			--	if currentDate.equalsD(startDate) or currentDate.beforeD(endDate) then
-- 					self.activeStatus := ActiveStatus::Closed
			--end;
		--end;
--		if self.sessionsInServ->slot->attendance->select(participant.isTypeOf(Tutor))->forAll(a | a.present = true) then
-- 			begin 
-- 				self.activeStatus := ActiveStatus::Ended
-- 			end;
-- 		end;
	
-- 	end
-- 	pre: self.tutor.accStatus <> delinquent and self.tutor.generalStatus <> Not_Approved
-- 	pre: self.tutor.schedule.attendance->size() > 0 ?
-- 	post: self.activeStatus <> null

-- requestOOOEnrollment(c: Child)
	-- pre: re tutor (t) of service: matchLevelforTutorandChild(t) <> MatchLevel::None)	

-- requestGroupEnrollment(c: Child)
	-- pre: re tutor (t) of service: matchLevelforTutorandChild(t) <> MatchLevel::None)	

constraints
	--If the mode of delivery is online then there is no meet location //UPDATE - TBD: if online, put online platform
    --inv:
    --self.modeOfDelivery.mod = ModeOfDelivery::Online implies self.location = null
	--inv MODisOLthenNull:
	--if self.MODofService.mod = ModeOfDelivery::Online implies self.location = NULL


	--number of enrollment requests with Accepted status <= numOfSpaces
	inv:
		self.EnrolRequest -> size() < self.EnrolRequest->select(acceptanceStatus = EnrollmentStatus::Accepted) -> size()
	--number of enrollment request associated with a service whose availability is NOT "free" should be 0
	inv:
		
	--If availability of service is not free it should have no enrollment request
	inv:
		self.availStatus <> AvailabilityStatus::Free implies self.EnrollRequest -> size()  = 0 

statemachines
	psm ServiceActiveStatus
	states 
		start: initial
		initialised [activeStatus = ActiveStatus::Not_Started and 
						currentDate.beforeD(startDate) = true
					]

		active [activeStatus = ActiveStatus::Active and 
					(currentDate.equalsD(startDate) or endDate.beforeD(currentDate)<>true) 
					and 
					enrolRequest->select(acceptanceStatus = EnrollmentStatus::Accepted)->size()>0
					and
					availStatus <> AvailabilityStatus::Service_Withdrawn
					]

		closed [activeStatus = ActiveStatus::Closed and 
					(currentDate.equalsD(startDate) and 
						enrolRequest->select(acceptanceStatus = EnrollmentStatus::Accepted)->size()=0
					)
					or  
					(currentDate.beforeD(endDate) and
						(availStatus = AvailabilityStatus::Not_Accepting_Requests
						or
						availStatus = AvailabilityStatus::Service_Withdrawn
						)
					)
				]
				
		ended: final [activeStatus = ActiveStatus::Ended and 
					currentDate.equalsD(endDate) 
					and 
					enrolRequest->select(acceptanceStatus = EnrollmentStatus::Accepted)->size()>0
			  ]

	transitions
		start -> initialised {create}
		initialised -> initialised {UpdateActiveStatus}
		initialised -> active {UpdateActiveStatus}
		initialised -> ended {UpdateActiveStatus}
		initialised -> closed {UpdateActiveStatus}
		active -> ended {UpdateActiveStatus}
		active -> closed {UpdateActiveStatus}
		closed -> active {UpdateActiveStatus}
		closed -> ended {UpdateActiveStatus}
	end 
end

class Review
attributes 
    rating: Ratings
    reviewTxt: String
operations
	setRating(r:Ratings) 
		begin
			self.rating := r;
			--if num of reviews >= 10, call updateAccStatus()
		end

	setReviewTxt(t:String)
		begin		
			self.reviewTxt := t;
		end 
constraints
	--A Parent may review a tutor only after rating a Tutor. 
    inv:
        self.rating = null implies self.reviewTxt = null
end 

class Payment
attributes
    amountPaid: Real
    datePaid: Date
operations
	deriveAmountToBePaid(m:Payment)
	begin
	end
end

class Message
attributes
	topic: String
	text: String
	date: DateTime
--operations
--constraints
end 

class Attachment
end

class Slot
attributes
	lessonInfo: String 
	date: Date
	-- time: String
	-- sessionNum: Integer
end

class SpecialNeed
attributes
	need: String
	description: String
end

class Certification
attributes
	name: String
	knowledgeArea: Subject -- having this be subject will make it easier to search 
	certifyingBody: String
	dateOfCertification: Date
	validDuration: Period
	--verifiedStatus
operations
	update(c:Certification)
	begin
	--doc and vd and the attachment needs to be updated 
	end
	--verifyCertification
end

class BulletinBoard 
attributes
	--?
end

-- -- EXTENDED ABSTRACT CLASSES --
-- abstract class Role < Receiver
-- attributes	
-- 	status: AccountStatus
-- end


-- EXTENDED CONCRETE CLASSES --
class DateTime < Date, Time
end

-- class Role < Receiver
-- attributes	
-- 	status: AccountStatus
-- end

class Child < Role
attributes
	chName: String
	gradeLvl: Grade
	dob: Date
	chSex: Sex
	age: Integer
-- operations
-- 	matchLevelforTutorandChild(t: Tutor): MatchLevel 
		--begin
			--result := MatchLevel::None
-- 			let childSubjects: Set(Subject) = subjects.subject, 
-- 				childMODs: Set(ModeOfDel) = modesOfDelivery.modeOfDel, 
-- 				childTOSs: Set(TypeOfService) = serviceTypes.typeOfService, 
-- 				subjBool: Boolean = t.subjects.subject->intersection(childSubjects)->size() > 0, 
-- 				modBool: Boolean = t.modesOfDelivery.modeOfDel->intersection(childMODs)->size() > 0, 
-- 				tosBool: Boolean = t.serviceTypes.typeOfService->intersection(childTOSs)->size() > 0 

-- 				in
				--if subjBool and not others, result := MatchLevel::Weak
				--if (subjBool and modBool) or (subjBool and tosBool), result := MatchLeveL::Moderate
				--if subjBool and modBool and tosBool, result := MatchLeveL::Strong
				--(IGNORE IF initialization after begin is possible) else, result := MatchLevel::None
			--end
			-- 	pre: self.subjects.subject->size() > 0 --child must have subjects
			-- pre: t.subjects.subject->size() > 0 --tutor must have subjects
			-- pre: modesOfDelivery.modeOfDel->size() > 0
			-- pre: t.modesOfDelivery.modeOfDel->size() > 0
			-- pre: serviceTypes.typeOfService->size() > 0
			-- pre: t.serviceTypes.typeOfService->size() > 0
			--pre: tutor generalStatus <> GeneralStatus::Not_Approved
			--post: if subjBool and not others, result := MatchLevel::Weak
			--post: if (subjBool and modBool) or (subjBool and tosBool), result := MatchLeveL::Moderate
			--post: if subjBool and modBool and tosBool, result := MatchLeveL::Strong
			--post: (IGNORE IF initialization after begin is possible) else, result := MatchLevel::None

--listWeakMatchTutors(): Set(Tutor)
-- 		begin
-- 			result := Tutor.allInstances()->select(t:Tutor|matchLevelforTutorandChild(t)=MatchLevel::Weak)
-- 		end 		
-- 	pre: self.subjects.subject->size() > 0 --child must have subjects
-- 	-- pre: t.subjects.subject->size() > 0 --tutor must have subjects
-- 	-- pre: modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: t.modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: serviceTypes.typeOfService->size() > 0
-- 	-- pre: t.serviceTypes.typeOfService->size() > 0
-- 	post: result = Tutor.allInstances()->select(t:Tutor|matchLevelforTutorandChild(t)=MatchLevel::Weak)


--listModerateMatchTutors(): Set(Tutor)
-- 		begin
-- 			result := Tutor.allInstances()->select(t:Tutor|matchLevelforTutorandChild(t)=MatchLevel::Moderate)
-- 		end 	
-- 	pre: self.subjects.subject->size() > 0 --child must have subjects
-- 	-- pre: t.subjects.subject->size() > 0 --tutor must have subjects
-- 	-- pre: modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: t.modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: serviceTypes.typeOfService->size() > 0
-- 	-- pre: t.serviceTypes.typeOfService->size() > 0
-- 	post: result = Tutor.allInstances()->select(t:Tutor|matchLevelforTutorandChild(t)=MatchLevel::Moderate)	


--listStrongMatchTutors(): Set(Tutor)
-- 		begin
-- 			result := Tutor.allInstances()->select(t:Tutor|matchLevelforTutorandChild(t)=MatchLevel::Strong)
-- 		end 		
-- 	pre: self.subjects.subject->size() > 0 --child must have subjects
-- 	-- pre: t.subjects.subject->size() > 0 --tutor must have subjects
-- 	-- pre: modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: t.modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: serviceTypes.typeOfService->size() > 0
-- 	-- pre: t.serviceTypes.typeOfService->size() > 0
-- 	post: result = Tutor.allInstances()->select(t:Tutor|matchLevelforTutorandChild(t)=MatchLevel::Strong)

--IGNORE:
-- 	listRelevantTutors(): Set(Tutor)
-- 		begin
-- 			result := Tutor.allInstances()->select(t:Tutor|isRelevantTutorForChild(t))
-- 		end 		
-- 	pre: self.subjects.subject->size() > 0 --child must have subjects
-- 	-- pre: t.subjects.subject->size() > 0 --tutor must have subjects
-- 	-- pre: modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: t.modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: serviceTypes.typeOfService->size() > 0
-- 	-- pre: t.serviceTypes.typeOfService->size() > 0
-- 	post: result = Tutor.allInstances()->select(t:Tutor|isRelevantTutorForChild(t))
constraints
	--A child must have a minimum age of 5 and a child must be below the age of 19. 
    inv ageFiveToNineteen:
        self.age >= 5 and self.age < 19
	
	-- Parents may only send enrollment requests to Tutors for a service whose availability is “free”.
	inv ServiceStatusmustBeFree: 
			self.service-> select(s:Service| s.availStatus= AvailabilityStatus::Free)
	

end

class Tutor < Role 
attributes
	generalStatus: GeneralStatus
	joinDate: Date 
	securityCode: Integer
	accStatus: AccountStatus init:AccountStatus::Good
--operations
	--updateAccStatus 
		--delinquent if >= 10 reviews and average rating is <=1 
		--delinquent if no subscription payment for last month (remember that if they don't pay monthly have to check months covered by last payment for year/3 months)
	

	--addOOOService() : Service
	--addGroupService(mod:ModeOfDel, subj:Subject, loc:String, numOfSpaces:Integer, currentDate:Date, startDate:Date, rate:Real) : Service
	
		--pre: accStatus <> delinquent and generalStatus <> Not_Approved
		--post: result.oclIsNew()
		--post: if type = ServiceType::Group then numOfSpaces > 1
		--post: if type = ServiceType::Group then service.location <> NULL, service.numOfSpaces>1, service.rate<>NULL -- for constraint 11
		--post: if type = ServiceType::One_On_One then numOfSpaces = 1
		--post: Service.allInstances -> size() = Service.allInstances@pre ->size() + 1


	--addCertification
	--confirmIdentity
	--updateGenStatus *verified if all certifications have verified status (not yet implemented)
constraints	
	--if status = delinquent all services should have service withdrawn status
	inv: 
		self.generalStatus = GeneralStatus::delinquent implies self.service->forall(s|s.availStatus = AvailabilityStatus::Service_Withdrawn)
	--Only tutors who are approved may offer services 
    inv:
        self.service->size() > 0 implies self.generalStatus <> GeneralStatus::Not_Approved
		
statemachines
	psm  AccountValidity
	states	
		start: initial 

		good [accStatus = AccountStatus::Good]

		delinquent [accStatus = AccountStatus::Delinquent]

	transitions
		start -> good {create}					
		-- good -> delinquent {updateAccStatus}
		-- delinquent -> good {updateAccStatus}
	end 
end

-- class BulletinBoard < Receiver
-- attributes
-- 	--?
-- end

class SpecialRequest < Message
attributes
	status: SRStatus init: SRStatus::Unanswered
	neededBy: Date
	currentDate: Date
	daysUntilNeeded: Integer
	daysPast: Integer 
-- operations
	-- setNeededBy(nb: Date) 
-- 	isRelevantTutorForSpecReq(t: Tutor): Boolean =
-- 			let srSubjects: Set(Subject) = subjects.subject, 
-- 				srMODs: Set(ModeOfDel) = modesOfDelivery.modeOfDel, 
-- 				subjBool: Boolean = t.subjects.subject->intersection(srSubjects)->size() > 0, 
-- 				modBool: Boolean = t.modesOfDelivery.modeOfDel->intersection(srMODs)->size() > 0 

-- 				in
				
-- 				subjBool and modBool and t.serviceTypes.typeOfService->select(type = ServiceType::One_On_One)->size() > 0


-- 	matchLevelforTutorandChild(t: Tutor): MatchLevel 
		--begin
			--result := MatchLevel::None
-- 			let childSubjects: Set(Subject) = subjects.subject, 
-- 				childMODs: Set(ModeOfDel) = modesOfDelivery.modeOfDel, 
-- 				childTOSs: Set(TypeOfService) = serviceTypes.typeOfService, 
-- 				subjBool: Boolean = t.subjects.subject->intersection(childSubjects)->size() > 0, 
-- 				modBool: Boolean = t.modesOfDelivery.modeOfDel->intersection(childMODs)->size() > 0, 
-- 				tosBool: Boolean = t.serviceTypes.typeOfService->intersection(childTOSs)->size() > 0 

-- 				in
				--if subjBool and not others, result := MatchLevel::Weak
				--if (subjBool and modBool) or (subjBool and tosBool), result := MatchLeveL::Moderate
				--if subjBool and modBool and tosBool, result := MatchLeveL::Strong
				--(IGNORE IF initialization after begin is possible) else, result := MatchLevel::None
			--end
			-- 	pre: self.subjects.subject->size() > 0 --child must have subjects
			-- pre: t.subjects.subject->size() > 0 --tutor must have subjects
			-- pre: modesOfDelivery.modeOfDel->size() > 0
			-- pre: t.modesOfDelivery.modeOfDel->size() > 0
			-- pre: serviceTypes.typeOfService->size() > 0
			-- pre: t.serviceTypes.typeOfService->size() > 0
			--pre: tutor generalStatus <> GeneralStatus::Not_Approved
			--post: if subjBool and not others, result := MatchLevel::Weak
			--post: if (subjBool and modBool) or (subjBool and tosBool), result := MatchLeveL::Moderate
			--post: if subjBool and modBool and tosBool, result := MatchLeveL::Strong
			--post: (IGNORE IF initialization after begin is possible) else, result := MatchLevel::None

--listWeakMatchTutors(): Set(Tutor)
-- 		begin
-- 			result := Tutor.allInstances()->select(t:Tutor|matchLevelforTutorandChild(t)=MatchLevel::Weak)
-- 		end 		
-- 	pre: self.subjects.subject->size() > 0 --child must have subjects
-- 	-- pre: t.subjects.subject->size() > 0 --tutor must have subjects
-- 	-- pre: modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: t.modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: serviceTypes.typeOfService->size() > 0
-- 	-- pre: t.serviceTypes.typeOfService->size() > 0
-- 	post: result = Tutor.allInstances()->select(t:Tutor|matchLevelforTutorandChild(t)=MatchLevel::Weak)


--listModerateMatchTutors(): Set(Tutor)
-- 		begin
-- 			result := Tutor.allInstances()->select(t:Tutor|matchLevelforTutorandChild(t)=MatchLevel::Moderate)
-- 		end 	
-- 	pre: self.subjects.subject->size() > 0 --child must have subjects
-- 	-- pre: t.subjects.subject->size() > 0 --tutor must have subjects
-- 	-- pre: modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: t.modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: serviceTypes.typeOfService->size() > 0
-- 	-- pre: t.serviceTypes.typeOfService->size() > 0
-- 	post: result = Tutor.allInstances()->select(t:Tutor|matchLevelforTutorandChild(t)=MatchLevel::Moderate)	


--listStrongMatchTutors(): Set(Tutor)
-- 		begin
-- 			result := Tutor.allInstances()->select(t:Tutor|matchLevelforTutorandChild(t)=MatchLevel::Strong)
-- 		end 		
-- 	pre: self.subjects.subject->size() > 0 --child must have subjects
-- 	-- pre: t.subjects.subject->size() > 0 --tutor must have subjects
-- 	-- pre: modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: t.modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: serviceTypes.typeOfService->size() > 0
-- 	-- pre: t.serviceTypes.typeOfService->size() > 0
-- 	post: result = Tutor.allInstances()->select(t:Tutor|matchLevelforTutorandChild(t)=MatchLevel::Strong)

--IGNORE:
-- 	listRelevantTutorsSR(): Set(Tutor)
-- 		begin
-- 			result := Tutor.allInstances()->select(t:Tutor|isRelevantTutorForSpecReq(t))
-- 		end 		
-- 	pre: self.subjects.subject->size() > 0 --Spec Req must have subjects
-- 	post: result = Tutor.allInstances()->select(t:Tutor|isRelevantTutorForSpecReq(t))
constraints
	--A Special Request existing without a date-needed-by date will become outdated after 31 days.
	inv:
		self.neededBy = null and self.daysPast = 31 implies self.status::Outdated 

	--if neededBy has passed then status = outdated
	inv SRisOutdated:
		self.neededBy.beforeD(self.currentDate) = false implies self.status = SRStatus::Outdated
		
	--only one of the proposals connected to a special request may have a status of Accepted
	inv:
		self.proposals.select(a:Proposal|a.accepted = true) -> size() <= 1


statemachines
	psm SpecialRequestStatus
	states	
		start: initial

		pending [status = SRStatus::Unanswered and proposals->size() = 0]

		answered [status = SRStatus::Answered and proposals->size() > 0]

		resolved: final [status = SRStatus::Resolved and proposals->select(accepted = true)->size() = 1]

		outdated [status = SRStatus::Outdated and 
					(proposals->size() = 0 	
					or 
						(daysPast >= 30 and proposals->select(accepted = true)->size() = 0)
				]

	transitions
		start -> pending {create}
		pending -> answered {} --missing submitProposal method
		answered -> resolved {} -- missing acceptProposal method
		answered -> outdated {} --missing method to check days past on special request
		outdated -> pending {} --missing updateDateNeededBy method
	end

end

class Proposal < Message
attributes
	accepted: Boolean
end

class Image < Attachment
end

class Video < Attachment
end

class Audio < Attachment
end

class PDF < Attachment
end

class WordDoc < Attachment
end


class Subscription < Payment
attributes 
	subscrPeriod: SubscriptionPeriod
	periodPaidFor: Period
	subscrRate: Integer
end

-- class PaymentToTutor < Payment
-- attributes
-- 	TutotServiceRate: Integer
-- end


-- ASSOCIATIONS IN MODEL -- 
association PersonRole between
	Person[1] role person
	Role[1..*] role roles
end

association ServiceOffering between
	Tutor[1] role tutor
	Service[*] role service
end

association TutorServiceReview between
	EnrolRequest[1] role tutorService
	Review[0..1] role review
end

association ServicePayments between
	EnrolRequest[1] role tutorService
	Payment[*] role payment
	-- PaymentToTutor[1..*] role payment
end

association SentMessages between
	Role[1] role sender
	Message[*] role sentMsgs
end  

-- association ReceivedMessages between
-- 	Receiver[1] role receiver
-- 	Message[*] role rcvdMsgs
-- end 

association ReceivedSRMessages between
	BulletinBoard[0..1] role srreceiver
	Message[*] role rcvdMsgs
end 

association ReceivedMessages between
	Role[0..1] role receiver
	Message[*] role rcvdMsgs
end 

association SpecReqResponses between
	-- SpecialRequest[1] role specialRequest 
	SpecialRequest[*] role specialRequests --see changes list in doc for reason
	Proposal[*] role proposals
end

association MsgMedia between
	Message[1] role message
	Attachment[*] role attachments 
end

--NEW--
association ScannedCert between
	Certification[1] role uploadedCert
	Attachment[*] role scan
end

-- association TutorSession between
-- 	Tutor[1] 
-- 	Session[*] 
-- end

-- association ChildSession between
-- 	Child[1] 
-- 	Session[*] 
-- end

association SessionSlots between
	-- Session[*] 
	Session[1]
	Slot[1..*]
end

association MembershipPayments between
	Tutor[1]
	-- Payment[*] role payments
	Subscription[1..*] role payments
end 


--Associations Replacing Sets--

association RoleSpecNeeds between
	Role[1]
	SpecialNeed[*] role specNeeds
end

association SpecReqSpecNeeds between
	SpecialRequest[1]
	SpecialNeed[*] role specNeeds
end

association tutorCertifications between
	Tutor[1]
	Certification[*] role certifications
end


-- >Role Sets<--
association  SubjectsOfInterest between
	Subject[*] role subjectOffering
	-- Role[1]
	Role[*]
end

association ModeOfInterest between
	ModeOfDel[*] role MODBeingOffered
	-- Role[1]
	Role[*]
end 

association ServiceTypeInterestedIn between
	TypeOfService[*] role TOSbeingOffered
	-- Role[1]
	Role[*]
end

-- >Service Association Sets
association SubjectOfTutorService between 
	Subject[1] role subjOfService
	-- Service[1]
	Service[*]
end 

-- association SubjectOfChildInterest between
-- 	Subject[*] role SubjsInterestedIn
-- 	Child[1]
-- end

association MODofTutorService between
	-- ModeOfDel[1..*] role MODofService
	ModeOfDel[1] role MODofService
	-- Service[1]
	Service[*]
end 

-- association MODofChildInterest between
-- 	ModeOfDel[*] role MODinterestedIn
-- 	Child[1]
-- end

association ServiceTypeOfTutorService between
	TypeOfService[1] role TypeOfTheService
	-- Service[1]
	Service[*]
end

-- association TOSofChildInterest between
-- 	TypeOfService[*] role TOSInterestedIn
-- 	Child[1]
-- end

association SessionsOfService between
	Session[1..*] role sessionsInServ
	Service[1] role serv
end

-- >Special Request Association Sets
association SubjectOfSR between
	-- Subject[*]
	Subject[1] --see changes list in doc for reason
	-- SpecialRequest[1]
	SpecialRequest[*]
end

association ModeOfInterestOfSR between
	-- ModeOfDel[*]
	ModeOfDel[1] 
	-- SpecialRequest[1]
	SpecialRequest[*]
end

association ServiceTypeOfInterestOfSR between
	-- TypeOfService[*]
	TypeOfService[1] 
	-- SpecialRequest[1]
	SpecialRequest[*]
end


-- ASSOCIATION CLASS -- 
associationclass EnrolRequest between
	Child[*] role tutee
	Service[*] role service
attributes
	acceptanceStatus: EnrollmentStatus 	init: EnrollmentStatus::Pending
	tutorAgreement: AgrStatus	 init: AgrStatus::Disagree
    parentAgreement: AgrStatus 		init: AgrStatus::Disagree
-- operations
	--updateAcceptStatus() --what argument? string ('A', 'D') A-Accept, D - Deny, boolean?
		--if accepting, check numOfSpaces and compare to size of set of EnrolReq objects with accepted status (from Service)
			-- if set size is = numOfSpaces, acceptanceStatus = EnrollmentStatus::Denied
			--else acceptanceStatus = EnrollmentStatus::Accepted
		--if denying, acceptanceStatus = EnrollmentStatus::Denied

		--pre: 
		--post: if accepting and set size is < numOfSpaces, acceptanceStatus = Accepted
		--post: if accepting and set size is = numOfSpaces, acceptanceStatus = Denied

-- 	canReviewService() : Boolean =
-- 		let attendances: Set(Attendance) = tutee.schedule.attendance, 
-- 			numOfSlots: Integer = attendances->size()

-- 		 in
-- 			attendances.select(present = true)->size() >= numOfSlots/2
-- 			and
-- 			self.acceptanceStatus = EnrollmentStatus::Accepted
		
-- 	reviewService(rating:Ratings, text:String)
-- 		begin
-- 			declare r:Review;
-- 			r := new Review();
-- 			r.setRating(rating);
-- 			r.setReviewTxt(text);
-- 		end
	
-- 	pre: canReviewService()
-- 	pre: text <> null 
-- 	pre: rating <> null 
-- 	post: self.review = text 
-- 	post: self.service.enrolRequest.review->size() = self.service.enrolRequest.review@pre->size() + 1

	--setting of attributes differs based on value for serviceType of the Service
constraints
	-- consider multiplicities for group vs ooo

	-- re tutor (t) of service: matchLevelforTutorandChild(t) <> MatchLevel::None)	

	-- Before a child is enrolled into a Tutor’s Service, both tutor and parent must agree to the terms of service
	inv AcceptanceIfAgree: 
		(self.tutorAgreement = AgrStatus::Agree and self.parentAgreement = AgrStatus::Agree implies self.EnrollmentStatus::Accepted) and
		(self.tutorAgreement = AgrStatus::Disagree and self.parentAgreement = AgrStatus::Agree implies self.EnrollmentStatus = acceptanceStatus::Pending) and
		(self.tutorAgreement = AgrStatus::Agree and self.parentAgreement = AgrStatus::Disagree implies self.EnrollmentStatus = acceptanceStatus::Pending) and
		(self.tutorAgreement = AgrStatus::Disagree and self.parentAgreement = AgrStatus::Disagree implies self.EnrollmentStatus = acceptanceStatus::Denied)

statemachines
	psm EnrollRequestStatus
	states	
		start: inital 

		pending [acceptanceStatus = EnrollmentStatus::Pending and tutorAgreement = AgrStatus::Disagree and parentAgreement = AgrStatus::Disagree]

		accepted [acceptanceStatus = EnrollmentStatus:Accepted and 
					tutee.matchLevelforTutorandChild(service.tutor) <> MatchLeveL::None 
					and 
					service.enrolRequest->select(acceptanceStatus = EnrollmentStatus::Accepted)->size < service.numOfSlots
				]

		denied [acceptanceStatus = EnrollmentStatus::Denied]
	
	transitions
		start-> pending {create}
		-- pending -> accepted {updateAcceptStatus} 
		-- pending -> denied {updateAcceptStatus}
		-- denied -> accepted {updateAcceptStatus}
		-- accepted -> denied {updateAcceptStatus}
	end
end 


associationclass Attendance between
	Role[1..*] role participant
	Slot[*] role classDate
attributes
	present: Boolean
end

