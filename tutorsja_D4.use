/* Group: TripleJ */

model TutorsJA


-- ENUMS -- 
enum Sex {Male, Female}
enum Grade {Kg3, One, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Eleven}
enum GeneralStatus {Not_Approved, Approved, Verified}
enum AccountStatus {Good, Delinquent}
enum Days {Mon, Tue, Wed, Thru, Fri, Sat, Sun}
enum ModeOfDelivery {Online, Face_To_Face, Blended}
enum ServiceType {One_On_One, Group}
enum AvailabilityStatus {Free, Fully_Booked, Not_Accepting_Requests, Service_Withdrawn}
enum ActiveStatus {Not_Started, Active, Ended, Closed}
enum EnrollmentStatus {Accepted, Denied, Pending}
enum AgrStatus{Agree, Disagree}
enum Ratings {STAR1, STAR2, STAR3, STAR4, STAR5}
enum SRStatus {Unanswered, Answered, Resolved, Outdated}
enum SubscriptionPeriod{Monthly, ThreeMonths, Annual}



-- DATATYPE CLASSES --
class Date 
attributes 
	hour: Integer
	min: Integer
    day: Integer
    month: Integer
    year: Integer
operations
    DateInit(d: Integer, m: Integer, y: Integer, h: Integer, min: Integer)
    begin
        self.day := d;
        self.month := m;
        self.year:= y;
		self.hour := h;
		self.min := min;
    end

	equals(d: Date)
	begin
	end

	before(d: Date)
	begin
	end
end

class Period  
attributes
    startDate: Date
    endDate: Date
operations
    PeriodInit(sDate: Date, eDate: Date)
    begin
        self.startDate := sDate;
        self.endDate := eDate;
    end

	equals(p:Period)
	begin
	end

	isGreaterThan(p:Period)
	begin
	end

	before(p:Period)
	begin
	end

	overlap(p:Period)
	begin
	end

	contains(p:Period)
	begin
	end
end

class Subject
attributes
	name: String
	gradeLevel: Grade
end

class Session
attributes
	day: Days
	startTime: Date
	endTime: Date
	recurring: Boolean
	startRecurring: Date
	endRecurring: Date
	duration: Period
    -- initialDur: Period --?
end

class ModeOfDel
attributes
	mod: ModeOfDelivery
end

class TypeOfService
attributes		
	type: ServiceType
end


-- ABSTRACT CLASSES --

abstract class Receiver
attributes
end 



-- CONCRETE CLASSES --

class Person
attributes
	fname: String
	lname: String
	username: String
	password: String
	sex: Sex
	isParent: Boolean
	location: String
--operations
constraints
	--<= 1 tutor role
	--isParent=True implies >= 1 child role
end 

class Service
attributes
	gradeLvl: Grade
    location: String
    numOfSpaces: Integer
    currentDate: Date 
    rate: Real
    availStatus: AvailabilityStatus
	activeStatus: ActiveStatus 
-- operations
-- 	UpdateActiveStatus()
-- 	begin
-- 		if self.tutor.schedule.attendance->forAll(a | a.present = true) then
-- 			begin 
-- 				self.activeStatus := ActiveStatus::Closed
-- 			end;
-- 		end;
-- 		if self.tutor.schedule.attendance->exists(a | a.present = true) then
-- 			begin 
-- 				self.activeStatus := ActiveStatus::Active
-- 			end;
-- 		else
-- 			begin 
-- 				self.activeStatus := ActiveStatus::Not_Started
-- 			end;
-- 		end;

-- 	end
-- 	pre: self.tutor.schedule.attendance->size() > 0 
-- 	post: self.activeStatus <> null
constraints
	--If the mode of delivery is online then there is no meet location
    -- inv:
    --     self.modeOfDelivery.mod = ModeOfDelivery::Online implies self.location = null
end

class Review
attributes 
    rating: Ratings
    reviewTxt: String
operations
	setRating(r:Ratings) 
		begin
			self.rating := r;
		end

	setReviewTxt(t:String)
		begin		
			self.reviewTxt := t;
		end 
constraints
	--A Parent may review a tutor only after rating a Tutor. 
    inv:
        self.rating = null implies self.reviewTxt = null
end 

class Payment
attributes
    amountPaid: Real
    datePaid: Date
operations
	deriveAmountToBePaid(m:Payment)
	begin
	end
end

class Message
attributes
	topic: String
	text: String
	date: Date
--operations
--constraints
end 

class Attachment
end

class Slot
attributes
	lessonInfo: String 
	date: Date
	time: String
	-- sessionNum: Integer
end

class SpecialNeed
attributes
	need: String
	description: String
end

class Certification
attributes
	name: String
	knowledgeArea: Subject -- having this be subject will make it easier to search 
	certifyingBody: String
	dateOfCertification: Date
	validDuration: Period
operations
	update(c:Certification)
	begin
	--doc and vd and the attachment needs to be updated 
	end
end


-- EXTENDED CONCRETE CLASSES --
class Role < Receiver
attributes	
	status: AccountStatus
end

class Child < Role
attributes
	chName: String
	gradeLvl: Grade
	dob: Date
	chSex: Sex
	age: Integer
-- operations
-- 	isRelevantTutorForChild(t: Tutor): Boolean =
-- 			let childSubjects: Set(Subject) = subjects.subject, 
-- 				childMODs: Set(ModeOfDel) = modesOfDelivery.modeOfDel, 
-- 				childTOSs: Set(TypeOfService) = serviceTypes.typeOfService, 
-- 				subjBool: Boolean = t.subjects.subject->intersection(childSubjects)->size() > 0, 
-- 				modBool: Boolean = t.modesOfDelivery.modeOfDel->intersection(childMODs)->size() > 0, 
-- 				tosBool: Boolean = t.serviceTypes.typeOfService->intersection(childTOSs)->size() > 0 

-- 				in
				
-- 				subjBool and modBool and tosBool

-- 	listRelevantTutors(): Set(Tutor)
-- 		begin
-- 			result := Tutor.allInstances()->select(t:Tutor|isRelevantTutorForChild(t))
-- 		end 		
-- 	pre: self.subjects.subject->size() > 0 --child must have subjects
-- 	-- pre: t.subjects.subject->size() > 0 --tutor must have subjects
-- 	-- pre: modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: t.modesOfDelivery.modeOfDel->size() > 0
-- 	-- pre: serviceTypes.typeOfService->size() > 0
-- 	-- pre: t.serviceTypes.typeOfService->size() > 0
-- 	post: result = Tutor.allInstances()->select(t:Tutor|isRelevantTutorForChild(t))
constraints
	--A child must have a minimum age of 5 and a child must be below the age of 19. 
    inv ageFiveToNineteen:
        self.age >= 5 and self.age < 19

	--person:isParent = True implies cannot enrol with tutors who belong to the same person
end

class Tutor < Role 
attributes
	generalStatus: GeneralStatus
	securityCode: Integer
--operations
constraints	
	--Only tutors who are approved may offer services 
    inv:
        self.service->size() > 0 implies self.generalStatus <> GeneralStatus::Not_Approved
		
	--cannot enrol children who belong to the same person
end

class BulletinBoard < Receiver
attributes
	--?
end

class SpecialRequest < Message
attributes
	status: SRStatus
	neededBy: Date
	daysPast: Integer
-- operations
-- 	isRelevantTutorForSpecReq(t: Tutor): Boolean =
-- 			let srSubjects: Set(Subject) = subjects.subject, 
-- 				srMODs: Set(ModeOfDel) = modesOfDelivery.modeOfDel, 
-- 				subjBool: Boolean = t.subjects.subject->intersection(srSubjects)->size() > 0, 
-- 				modBool: Boolean = t.modesOfDelivery.modeOfDel->intersection(srMODs)->size() > 0 

-- 				in
				
-- 				subjBool and modBool and t.serviceTypes.typeOfService->select(type = ServiceType::One_On_One)->size() > 0

-- 	listRelevantTutorsSR(): Set(Tutor)
-- 		begin
-- 			result := Tutor.allInstances()->select(t:Tutor|isRelevantTutorForSpecReq(t))
-- 		end 		
-- 	pre: self.subjects.subject->size() > 0 --Spec Req must have subjects
-- 	post: result = Tutor.allInstances()->select(t:Tutor|isRelevantTutorForSpecReq(t))
constraints
	--Receiver must be Bulletin Board
end

class Proposal < Message
attributes
	--?
end

class Image < Attachment
end

class Video < Attachment
end

class Audio < Attachment
end

class PDF < Attachment
end

class WordDoc < Attachment
end


class Subscription < Payment
attributes 
	SubscrPeriod: SubscriptionPeriod
	SubscrRate: Integer
end

class PaymentToTutor < Payment
attributes
	TutotServiceRate: Integer
end


-- ASSOCIATIONS IN MODEL -- 
association PersonRole between
	Person[1] role person
	Role[1..*] role roles
end

association ServiceOffering between
	Tutor[1] role tutor
	Service[*] role service
end

association TutorServiceReview between
	EnrolRequest[1] role tutorService
	Review[0..1] role review
end

association ServicePayments between
	EnrolRequest[1] role tutorService
	-- Payment[*] role payment
	PaymentToTutor[1..*] role payment
end

association SentMessages between
	Role[1] role sender
	Message[*] role sentMsgs
end  

association ReceivedMessages between
	Receiver[1] role receiver
	Message[*] role rcvdMsgs
end 

association SpecReqResponses between
	SpecialRequest[1] role specialRequest 
	Proposal[*] role proposals
end

association MsgMedia between
	Message[1] role message
	Attachment[*] role attachments 
end
--NEW--
association ScannedCert between
	Certification[1] role uploadedCert
	Attachment[*] role scan
end

association TutorSession between
	Tutor[1] 
	Session[*] 
end

association ChildSession between
	Child[1] 
	Session[*] 
end

association SessionSlots between
	Session[*] 
	Slot[1..*]
end

association MembershipPayments between
	Tutor[1]
	-- Payment[*] role payments
	Subscription[1..*] role payments
end 

--Associations Replacing Sets--

association RoleSpecNeeds between
	Role[1]
	SpecialNeed[*] role specNeeds
end

association SpecReqSpecNeeds between
	SpecialRequest[1]
	SpecialNeed[*] role specNeeds
end

association tutorCertifications between
	Tutor[1]
	Certification[*] role certifications
end


-- >Role Sets<--
association  SubjectsOfInterest between
	Subject[*] role subjectOffering
	Role[1]
end

association ModeOfInterest between
	ModeOfDel[*] role MODBeingOffered
	Role[1]
end 

association ServiceTypeInterestedIn between
	TypeOfService[*] role TOSbeingOffered
	Role[1]
end

-- >Service Association Sets
association SubjectOfTuterService between 
	Subject[1] role subjOfService
	Service[1]
end 

association SubjectOfChildInterest between
	Subject[*] role SubjsInterestedIn
	Child[1]
end

association MODofTuorService between
	ModeOfDel[1..*] role MODofService
	Service[1]
end 

association MODofChildInterest between
	ModeOfDel[*] role MODinterestedIn
	Child[1]
end

association ServiceTypeOfTutorService between
	TypeOfService[1] role TypeOfTheService
	Service[1]
end

association TOSofChildInterest between
	TypeOfService[*] role TOSInterestedIn
	Child[1]
end

association SessionsOfService between
	Session[1..*] role sessionsInServ
	Service[1] role serv
end

-- >Special Request Association Sets
association SubjectOfSR between
	Subject[*]
	SpecialRequest[1]
end

association ModeOfInterestOfSR between
	ModeOfDel[*]
	SpecialRequest[1]
end



-- ASSOCIATION CLASS -- 
associationclass EnrolRequest between
	Child[*] role tutee
	Service[*] role service
attributes
	acceptanceStatus: EnrollmentStatus
	tutorAgreement: AgrStatus
    parentAgreement: AgrStatus
-- operations
-- 	canReviewService() : Boolean =
-- 		let attendances: Set(Attendance) = tutee.schedule.attendance, 
-- 			numOfSlots: Integer = attendances->size()

-- 		 in
-- 			attendances.select(present = true)->size() >= numOfSlots/2
-- 			and
-- 			self.acceptanceStatus = EnrollmentStatus::Accepted
		
-- 	reviewService(rating:Ratings, text:String)
-- 		begin
-- 			declare r:Review;
-- 			r := new Review();
-- 			r.setRating(rating);
-- 			r.setReviewTxt(text);
-- 		end
	
-- 	pre: canReviewService()
-- 	pre: text <> null 
-- 	pre: rating <> null 
-- 	post: self.review = text 
-- 	post: self.service.enrolRequest.review->size() = self.service.enrolRequest.review@pre->size() + 1

	--setting of attributes differs based on value for serviceType of the Service
constraints
	-- consider multiplicities for group vs ooo
end 


associationclass Attendance between
	Role[*] role participant
	Slot[1..*] role lesson
attributes
	present: Boolean
end
